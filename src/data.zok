/** Data structures */

// ZoKrates does not support constants here yet.
struct Stack {
	u32[16] values
	u32 length
}

// Size of values must be the same as MEMORY_SIZE.
// ZoKrates does not support constants here yet.
struct Memory {
	u32[16] values
}

struct State {
	Stack stack
	Memory memory
	u32 pc
	bool running
	bool error
}

// Instructions size must be the same as PROGRAM_SIZE.
// ZoKrates does not support constants here yet.
struct Program {
	// Uncomment this for old smaller tests \/
	//u32[17] instructions
	// Uncomment this for dec test \/
	u32[19] instructions
}

// Size of values must be the same as CALLDATA_SIZE.
// ZoKrates does not support constants here yet.
struct Calldata {
	u32[19] values
}

/*******************/

/** Size constants */

const u32 MEMORY_SIZE = 16
// To see the state before it crashes uncomment this and do not load the state (use the 0 initial in vm.zok)
// Uncomment this for old smaller tests \/
//const u32 PROGRAM_SIZE = 17
// Uncomment this for dec test \/
const u32 PROGRAM_SIZE = 30

// To crash do this \/ without loading the state
const u32 PROGRAM_ITERATIONS = 1
// If you load the state, this runs the one iteration that fails when you use 44
//const u32 PROGRAM_ITERATIONS = 20

const u32 CALLDATA_SIZE = 19

const u32 STACK_HEAD_START = 0
const u32 STACK_SIZE = 16

/*******************/

/** Stack helpers */

def hasAtLeast<N>(Stack s) -> bool:
	return s.length >= STACK_HEAD_START + N

def hasAtMost<N>(Stack s) -> bool:
	return (s.length + (- STACK_HEAD_START)) <= N

def nth<N>(Stack s) -> u32:
	return s.values[s.length + (- N)]

def first(Stack s) -> u32:
	return nth::<1>(s)

def second(Stack s) -> u32:
	return nth::<2>(s)

def third(Stack s) -> u32:
	return nth::<3>(s)

def decrease<L>(Stack s) -> Stack:
	s.length = if s.length >= L then s.length + (- L) else STACK_HEAD_START fi
	return s

def increase<L>(Stack s) -> Stack:
	s.length = s.length + L
	return s

def writeTop(Stack s, u32 n) -> Stack:
	s.values[s.length] = n
	s = increase::<1>(s)
	return s

def writeFirst<L>(State s, u32 n) -> State:
	s.stack = decrease::<L>(s.stack)
	s.stack = writeTop(s.stack, n)
	return s

def write<L>(Stack s, u32 n) -> Stack:
	s.values[s.length + (- L)] = n
	return s

/*******************/

/** State helpers */

def stop(State s) -> State:
	s.running = false
	return s

def error(State s) -> State:
	s.error = true
	return s

/*******************/
