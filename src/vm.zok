from "./data.zok" import Stack, Memory, State, Program, Calldata, MEMORY_SIZE, PROGRAM_SIZE, CALLDATA_SIZE, STACK_HEAD_START, STACK_SIZE, stop, error

from "./opcodes.zok" import STOP, ADD, JUMP, JUMPI, CALLDATALOAD, PUSH32, DUP1, add, pop, jump, jumpi, calldataload, mload, mstore, push, dup1

def main(u32 memoryHash, u32 stackHash, Program program, private Calldata calldata) -> State:
	// Start with empty stack and empty memory.
	State s = State {
		stack: Stack { values: [0; STACK_SIZE + STACK_HEAD_START], length: STACK_HEAD_START },
		memory: Memory { values: [0; MEMORY_SIZE] },
		pc: 0,
		running: true,
		error: false
	}

	for u32 i in 0..PROGRAM_SIZE do
		u32 instr = program.instructions[s.pc]

		// Compute all possible future states nondeterministically.
		State s1 = stop(s)
		State s2 = add(s)
		State s3 = jump(s)
		State s4 = jumpi(s)
		State s5 = calldataload(s, calldata)
		State s6 = push(s, program)
		State s7 = dup1(s)

		// Choose the appropriate data path and sync.
		s = \
			if (!s.running) then s else \
			if (instr == STOP) then s1 else \
			if (instr == ADD) then s2 else \
			if (instr == JUMP) then s3 else \
			if (instr == JUMPI) then s4 else \
			if (instr == CALLDATALOAD) then s5 else \
			if (instr == PUSH32) then s6 else \
			if (instr == DUP1) then s7 else \
				error(s) \
			fi \
			fi \
			fi \
			fi \
			fi \
			fi \
			fi \
			fi

		s.pc = if s.running then (s.pc + 1) else s.pc fi

		assert(!s.error)

		// Ensure that the stack guard values are not corrupted.
		for u32 j in 0..STACK_HEAD_START do
			assert(s.stack.values[j] == 0)
		endfor

	endfor

	assert(!s.error)
	// Execution should have stopped.
	assert(!s.running)

	// Ensure that the stack guard values are not corrupted.
	for u32 j in 0..STACK_HEAD_START do
		assert(s.stack.values[j] == 0)
	endfor

	return s
