from "./data.zok" import Stack, Memory, State, Program, Calldata, MEMORY_SIZE, PROGRAM_SIZE, CALLDATA_SIZE, STACK_SIZE, hasAtLeast, hasAtMost, first, second, third, decrease, increase, writeTop, writeFirst, error

/** Opcode constants */

const u32 ADD = 1
const u32 CALLDATALOAD = 2
const u32 STOP = 3
const u32 PUSH = 4

/*******************/

/** Opcodes */

def add(State s) -> State:
	bool e = !s.running || !hasAtLeast::<2>(s.stack)
	return if e then error(s) else writeFirst::<2>(s, first(s.stack) + second(s.stack)) fi

// If at ANY point, ANY number >= c.values.length ends up on the stack,
// the index access below WILL throw due to the nondeterministic calldataload
// branch in the main interpreter loop.
// This happens whether one uses calldataload or not.
// The workaround for this is to use a patched ZoKrates that does not throw
// at out of bounds, and make sure the actual execution does not reach that.
def calldataload(State s, Calldata c) -> State:
	bool e = !s.running || !hasAtLeast::<1>(s.stack) || first(s.stack) >= CALLDATA_SIZE
	return if e then error(s) else writeFirst::<1>(s, c.values[first(s.stack)]) fi

def mload(State s) -> State:
	bool e = !s.running || !hasAtLeast::<1>(s.stack) || first(s.stack) >= MEMORY_SIZE
	return if e then error(s) else writeFirst::<1>(s, s.memory.values[first(s.stack)]) fi

def mstore(State s) -> State:
	bool e = !s.running || !hasAtLeast::<2>(s.stack) || first(s.stack) >= MEMORY_SIZE
	s.stack = decrease::<2>(s.stack)
	s.memory.values[first(s.stack)] = second(s.stack)
	return if e then error(s) else s fi

def push(State s, Program p) -> State:
	s.pc = s.pc + 1
	u32 l = STACK_SIZE + (- 2)
	bool e = !s.running || !hasAtMost::<l>(s.stack)

	u32 x = p.instructions[s.pc]
	s.stack = writeTop(s.stack, x)
	return if e then error(s) else s fi
