// STACK ACCESS UNDERFLOW:
// The circuit form means that every branch is "executed" regardless of
// the branch conditions. This means that the code will try to read from
// the stack even when the stack is empty. This leads to exceptions being
// thrown even when everything is fine.
// To aid that, we give the stack a buffer of size 5, so that no stack read
// operation underflows. This only leads to wrong data, which is fine
// since the final data is restricted by the branch conditions.

/** Data structures */

struct Stack {
	// STACK_SIZE + STACK_HEAD_START
	u32[18] values
	u32 length
}

struct Memory {
	u32[16] values
}

struct State {
	Stack stack
	Memory memory
	u32 pc
	bool running
	bool error
}

// Instructions size must be > PROGRAM_SIZE
// because in the nondeterministic main loop future execution loopkup
// the PUSH instruction is always executed. It then tries to lookup
// position s.pc + 1, even though s.pc might be the last.
struct Program {
	u32[7] instructions
}

struct Calldata {
	u32[1] values
}

/*******************/

/** Size constants */

const u32 MEMORY_SIZE = 16
const u32 PROGRAM_SIZE = 6
const u32 CALLDATA_SIZE = 1
// See STACK ACCESS UNDERFLOW above.
const u32 STACK_HEAD_START = 2
const u32 STACK_SIZE = 16

/*******************/

/** Opcode constants */

const u32 ADD = 1
const u32 CALLDATALOAD = 2
const u32 STOP = 3
const u32 PUSH = 4

/*******************/

/** Stack helpers */

def hasAtLeast<N>(Stack s) -> bool:
	return s.length >= STACK_HEAD_START + N

def hasAtMost<N>(Stack s) -> bool:
	return (s.length + (- STACK_HEAD_START)) <= N

def nth<N>(Stack s) -> u32:
	return s.values[s.length + (- N)]

def first(Stack s) -> u32:
	return nth::<1>(s)

def second(Stack s) -> u32:
	return nth::<2>(s)

def third(Stack s) -> u32:
	return nth::<3>(s)

def decrease<L>(Stack s) -> Stack:
	s.length = s.length + (- L)
	return s

def increase<L>(Stack s) -> Stack:
	s.length = s.length + L
	return s

def writeTop(Stack s, u32 n) -> Stack:
	s.values[s.length] = n
	s = increase::<1>(s)
	return s

def writeFirst<L>(State s, u32 n) -> State:
	s.stack = decrease::<L>(s.stack)
	s.stack = writeTop(s.stack, n)
	return s

/*******************/

/** State helpers */

def stop(State s) -> State:
	s.running = false
	return s

def error(State s) -> State:
	s.error = true
	return s

/*******************/

/** Opcodes */

def add(State s) -> State:
	bool e = !s.running || !hasAtLeast::<2>(s.stack)
	//return if e then error(s) else s fi
	return if e then error(s) else writeFirst::<2>(s, first(s.stack) + second(s.stack)) fi

def calldataload(State s, Calldata c) -> State:
	bool e = !s.running || !hasAtLeast::<1>(s.stack) || first(s.stack) >= CALLDATA_SIZE
	return if e then error(s) else writeFirst::<1>(s, c.values[first(s.stack)]) fi

def mload(State s) -> State:
	bool e = !s.running || !hasAtLeast::<1>(s.stack) || first(s.stack) >= MEMORY_SIZE
	return if e then error(s) else writeFirst::<1>(s, s.memory.values[first(s.stack)]) fi

def mstore(State s) -> State:
	bool e = !s.running || !hasAtLeast::<2>(s.stack) || first(s.stack) >= MEMORY_SIZE
	s.stack = decrease::<2>(s.stack)
	s.memory.values[first(s.stack)] = second(s.stack)
	return if e then error(s) else s fi

def push(State s, Program p) -> State:
	s.pc = s.pc + 1
	u32 l = STACK_SIZE + (- 2)
	bool e = !s.running || !hasAtMost::<l>(s.stack)

	u32 x = p.instructions[s.pc]
	s.stack = writeTop(s.stack, x)
	return if e then error(s) else s fi

def main(u32 memoryHash, u32 stackHash, Program program, private Calldata calldata) -> State:
	State s = State {
		stack: Stack { values: [0; STACK_SIZE + STACK_HEAD_START], length: STACK_HEAD_START },
		memory: Memory { values: [0; MEMORY_SIZE] },
		pc: 0,
		running: true,
		error: false
	}

	for u32 i in 0..PROGRAM_SIZE do
		u32 instr = program.instructions[s.pc]

		// Compute all possible future states nondeterministically.
		State s1 = add(s)
		State s2 = stop(s)
		State s3 = push(s, program)
		State s4 = calldataload(s, calldata)

		// Chose the appropriate one.
		s = \
			if (!s.running) then s else \
			if (instr == ADD) then s1 else \
			if (instr == STOP) then s2 else \
			if (instr == PUSH) then s3 else \
			if (instr == CALLDATALOAD) then s4 else \
				error(s) \
			fi \
			fi \
			fi \
			fi \
			fi

		s.pc = if s.running then (s.pc + 1) else s.pc fi
		assert(!s.error)

	endfor

	assert(!s.error)
	assert(!s.running)
	//assert(memoryHash == sha256(s.memory))
	//assert(stackHash == sha256(s.stack.value))
	return s
