/** Data structures */

// Size of values must be STACK_SIZE + STACK_HEAD_START
// ZoKrates does not support constants here yet.
// STACK ACCESS UNDERFLOW:
// The circuit form means that every branch is "executed" regardless of
// the branch conditions. This means that the code will try to read from
// the stack even when the stack is empty. This leads to exceptions being
// thrown even when everything is fine.
// To aid that, we give the stack a buffer of size STACK_HEAD_START, so that no stack read
// operation underflows. This only leads to wrong data, which is fine
// since the final data is restricted by the branch conditions.
struct Stack {
	u32[18] values
	u32 length
}

// Size of values must be the same as MEMORY_SIZE.
// ZoKrates does not support constants here yet.
struct Memory {
	u32[16] values
}

struct State {
	Stack stack
	Memory memory
	u32 pc
	bool running
	bool error
}

// Instructions size must be > PROGRAM_SIZE
// because in the nondeterministic main loop future execution lookup
// the PUSH instruction is always executed.
// It then tries to lookup position s.pc + 1, even though s.pc might be the last.
// Size of values must be the same as MEMORY_SIZE.
// ZoKrates does not support constants here yet.
struct Program {
	u32[11] instructions
}

// Size of values must be the same as CALLDATA_SIZE.
// ZoKrates does not support constants here yet.
struct Calldata {
	u32[10] values
}

/*******************/

/** Size constants */

const u32 MEMORY_SIZE = 16
const u32 PROGRAM_SIZE = 10
const u32 CALLDATA_SIZE = 10

const u32 STACK_HEAD_START = 2
const u32 STACK_SIZE = 16

/*******************/

/** Stack helpers */

def hasAtLeast<N>(Stack s) -> bool:
	return s.length >= STACK_HEAD_START + N

def hasAtMost<N>(Stack s) -> bool:
	return (s.length + (- STACK_HEAD_START)) <= N

def nth<N>(Stack s) -> u32:
	return s.values[s.length + (- N)]

def first(Stack s) -> u32:
	return nth::<1>(s)

def second(Stack s) -> u32:
	return nth::<2>(s)

def third(Stack s) -> u32:
	return nth::<3>(s)

def decrease<L>(Stack s) -> Stack:
	s.length = s.length + (- L)
	return s

def increase<L>(Stack s) -> Stack:
	s.length = s.length + L
	return s

def writeTop(Stack s, u32 n) -> Stack:
	s.values[s.length] = n
	s = increase::<1>(s)
	return s

def writeFirst<L>(State s, u32 n) -> State:
	s.stack = decrease::<L>(s.stack)
	s.stack = writeTop(s.stack, n)
	return s

/*******************/

/** State helpers */

def stop(State s) -> State:
	s.running = false
	return s

def error(State s) -> State:
	s.error = true
	return s

/*******************/
